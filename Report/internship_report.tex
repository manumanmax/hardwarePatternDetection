\documentclass[english,a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\PassOptionsToPackage{english}{babel}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{eso-pic}
\usepackage{cite}
\usepackage{wrapfig}
\usepackage{url}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{listings}

\usepackage[lastpage,user]{zref}
\cfoot{\thepage\ of \zpageref{LastPage}}
\pagestyle{fancy}
\usepackage[headsep=1cm,headheight=61pt,footskip=3cm]{geometry}


\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
 \newcommand{\ts}{\textsuperscript}
\newcommand{\blap}[1]{\vbox to 0pt{#1\vss}}
\newcommand\AtUpperLeftCorner[3]{%
  \put(\LenToUnit{#1},\LenToUnit{\dimexpr\paperheight-#2}){\blap{#3}}%
}
\newcommand\AtUpperRightCorner[3]{%
  \put(\LenToUnit{\dimexpr\paperwidth-#1},\LenToUnit{\dimexpr\paperheight-#2}){\blap{\llap{#3}}}%
}
\newcommand\AtLowerRightCorner[3]{%
  \put(\LenToUnit{\dimexpr\paperwidth-#1},\LenToUnit{#2}){#3}%
}
 
\title{\LARGE{Internship report pattern recognition UNISA Italy}}
\author{\textsc{Breton-Belz} Emmanuel - 2\ts{nd} Year Internship}
\date{\today}
\makeatletter

\renewcommand{\headrulewidth}{1pt}
\fancyhead[C]{\@author} 
\fancyhead[L]{\leftmark}
\fancyhead[R]{\includegraphics[width=2cm]{images_not_compressed/unisaLogo.jpg}}
\fancyhead[L]{{\includegraphics[width=2cm]{images_not_compressed/ensiLogo.jpg}}}
\addto\captionsenglish{
  \renewcommand{\contentsname}
    {Table of contents}
}
\renewcommand{\footrulewidth}{1pt}
\fancyfoot[R]{\leftmark}
		 
\begin{document}
	\setcounter{tocdepth}{4}
	\begin{titlepage}
	    \AddToShipoutPicture{%
	      \AtUpperLeftCorner{1.5cm}{1cm}{\includegraphics[width=4cm]{images_not_compressed/unisaLogo.jpg}}
	      \AtUpperRightCorner{1.5cm}{1cm}{\includegraphics[width=6.5cm]{images_not_compressed/ensiLogo.jpg}}
	      \AtLowerRightCorner{8cm}{3.5cm}{\parbox{7cm}{ENSICAEN \\
	        6, boulevard Maréchal Juin 
	        \\CS  45 053 – F- 14050 Caen Cedex 4\\
	        Tél. +33 (0)2 31 45 27 50\\
	        Fax +33 (0)2 31 45 27 60}} 
	    }
	 
	\begin{center}
	        \vspace*{10cm}
	        \textsc{\@title}
	        \HRule
	        \vspace*{0.5cm}
	        \large{\@author} 
	 \end{center}
 
    \vspace*{5cm}
    \begin{center}
      \makebox[\textwidth]{\includegraphics[width=\paperwidth]{images_not_compressed/uneGrandeEcole.png}}
    \end{center}
	
	\end{titlepage}
	\ClearShipoutPicture
	
	\input{thanks}
	
	
	
	\tableofcontents
	\newpage
	
	\setcounter{page}{1}
	
	\input{introduction}
	\input{MIVIA_Lab}
	\input{work_to_do}
	\input{study}
	\input{work_done}
	
	\par This part will a melting pot of issues and success and how I found out how to correct them if I could. I will gather the installations for OpenCV and the cross toolchain because the main idea is the same. Then I will spit the technical part in two as usual otherwise it will not be clear enough.	
	
	\section{Installation and tests}
	
	\subsection{Helmet}
	\subsubsection{Cross GCC}
	
	\par It is pretty easy to install, you have to get the archieve and compile the cross compiler for your architecture. First of all I saw in the tutorial that I was trying that a Ubuntu 10.04LTS\footnote{Long Lime Support} was required. I used virtual box to get a virtual machin\footnote{Software to emulate operating systems} of this distribution on my windows OS.	
	
	\subsubsection{Kernel compilation}
	\subsubsection{Test}
	
	\subsection{Pattern scanner}
	\subsubsection{OpenCV installation}

	\par I installed OpenCV 3.0 which is the last version and tried it. It has a base for basic image applications and modules that you can install by adding them to the module folder and compile them. Unfortunatly one module required to perform the test was not working with the 3.0 version. It is the non free module. I tryed several times but I finally decided to switch back to a previous version. After uninstall everything and install the 2.4.9 version. The module was functionnal. I tryed the code of the tutorial ~\hyperlink{opencv}{I quote earlier} and I had the first pattern recognition result. That took me 4 day in totall including the eclipse configuration that require adding all the libraries in the configuration of the compiler.
	
	\subsubsection{First build on eclipse}	
	
	\par As I just said, to make it work on eclipse I had to set the configuration for OpenCV project. Otherwise I does not compile. Right click on the project, propreties, than	go to the settings of my compiler (GCC  C++) and select includes. There I added the path to the local install folder where the OpenCV's includes are located. After that I had to set the libraries to link one by one. In the same window I went in libraries section and add their names like opencv\_core... And I added the search path of my local lib folder. Then I saved the setting and compilation was working.
	
	
	\section{Main problems}	
	\subsection{Related to the helmet}
	\subsubsection{Hardware}
	\subsubsection{Emulator}
	\subsubsection{•}
	
	\subsection{Related to the software}
	
	\subsubsection{The matcher}
	
	\par After 3 days of stagnation making some tests and learing about the matching system. Allessia, the thesis companion of Mario Vento made me realise that was on the wrong way using the match function of OpenCV. In fact I couldn't find multiple pattern with that method because it selects the nearest descriptors\footnote{Those which have a minimum hamming distance likeness}. The result was that I had to launch serval time the algorithm to get new matches again and again. I found the knnmatcher that perform a full matching and keeps the N best matches. That was not enough so I switched to the radius matcher that need a threshold parameter. That it finally how I introduce the threshold in the program. This value depends on the object, the distance and the conditions of the scene. In an other way the matcher keeps the matches which differ between the scene and the pattern less than the threshold.
	\par The algorithm return a vector of vector of DMatches\footnote{DMatch : A structure representing each match} so I put it in a simple vector of DMatches and it gave me very good results. The algorithm was able to find multiple time the same match on the scene. In the figure \ref{matches} we can see the fact that every time the pattern is represented it has matches in it. Not just the best ones which here corresponds to those of the first on the left.
	
	
	\begin{figure}[h]
		\begin{center}
			\includegraphics[width=10cm]{images_not_compressed/matches.jpg}
			\caption{Simple draw of radius match with 3 times the same match surround in red}
			\label{matches}	
		\end{center}
	\end{figure}
	
	\subsubsection[Multiple pattern]{Get many time the same pattern}

	\par On this part we extract two possible methods with Pierluigi. The easy one was to draw in black the image and than make the homography another time. The hardest one was to look for the key points and descriptor inside the corners and earase them of their containers. Than do the homography again. I began by the second one that sounded more relevent. 
	
	\par To be clear I have to present the DMatch structure that is detailed in the \hyperlink{structDMatch}{annexes}. The important attributs are the train index and the query index. They represent the fact that a descriptor has been found on the two images. But only the index of the descriptor is stored.
	
	\par I first thought I could get easily the points that gave me the corners after the homography. In fact I needed to remove the points that concern the pattern that has been recognized by the homography. There was no other way but to extract all the indexes of the points inside the corners I just found and remove them from the vectors. By chance, the homography take to vectors of points describing the positions of the descriptors (and the key points by the way). 
	\par On the first version of this algorithm I was looking if the point was in the bounds represented by the 4 segments of the rectangle of the pattern found. I found out when I was rotating the image that the points was removed the wrong way because the shape of the pattern was a lozenge. A lot of points was concidered out of the bounds and other that had nothing to do with the pattern was removed.
	\par I found on the internet a method~\cite{InOut} that provides the answer of my problem in O(n). This method find the number of edges that ligne from a point cross to the infinite with a polygon. If it is odd then the point is inside the polygon otherwise it is outside. The picture~\ref{OutIn} illustrate the idea.
	\begin{figure}[h]
		\begin{center}
			\includegraphics[width=10cm]{images_not_compressed/isIn.png}
			\caption{Illustration of the algorithm that tell if a point is inside a polygon}
			\label{OutIn}	
		\end{center}
	\end{figure}
	\subsubsection{Corners}

	\par The corners correspond to the vertices of the polygone that represents the pattern	
	
	\subsubsection{Others}
	
	\input{conclusion}

	\clearpage

	\bibliography{/home/manu/workspace/Scanner/Report/biblio_internship}{}
	\bibliographystyle{plain}

	\chapter{Annexes}
	
	\begin{itemize}
	\item
		\hypertarget{opencv}{\textbf{OpenCV tutorial :\\}}	\url{http://docs.opencv.org/doc/tutorials/features2d/feature_homography/feature_homography.html#feature-homography}\\

	\item
	\hypertarget{structDMatch}{\textbf{Code of the DMatch Structure :}}
	\begin{lstlisting}
struct DMatch
{
    DMatch() : queryIdx(-1), trainIdx(-1), imgIdx(-1),
               distance(std::numeric_limits<float>::max()) {}
    DMatch( int _queryIdx, int _trainIdx, float _distance ) :
            queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(-1),
            distance(_distance) {}
    DMatch( int _queryIdx, int _trainIdx, int _imgIdx, float _distance ) :
            queryIdx(_queryIdx), trainIdx(_trainIdx), imgIdx(_imgIdx),
            distance(_distance) {}

    int queryIdx; // query descriptor index
    int trainIdx; // train descriptor index
    int imgIdx;   // train image index

    float distance;

    // less is better
    bool operator<( const DMatch &m ) const;
};
	\end{lstlisting}	
	
\end{itemize}		
	


	\listoffigures
		
	
	
	
	\input{summary}

	
	
	
\end{document}